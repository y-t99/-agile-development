### 敏捷开发

&emsp;&emsp;原则（principle）、模式（pattern）和实践（practice）都是重要的，但是使它们发挥作用的是人。正如Alistair Cockburn所说的："过程和技术对于项目的结果只有次要的影响。首要的影响是人。"
&emsp;&emsp;如果把程序员团队看作是由过程驱动的组件（component）所组成的系统，那么就无法对他们进行管理。用Alistair Cockburn的话来说，人不是"插入即兼容的编程装置。" 如果想要项目取得成功，我们就必须构建起具有合作精神的、自组织（self-organizing）的团队。

#### 敏捷软件开发宣言

- 人和交互重于过程和工具。
- 可以工作的软件重于面面俱到的文档。
- 客户合作重于合同谈判。
- 随时应对变化重于遵循计划。

1. 人是获得成功的最为重要的因素。如果团队中没有优秀的成员，那么就算是使用好的过程也不能从失败中挽救项目。但是，不好的过程却可以使最优秀的团队成员失去效用。如果不能作为一个团队进行工作，那么即使拥有一批优秀的成员也一样会惨败。

   团队的构建要比环境的构建重要得多。

2. 没有文档的软件是一种灾难。代码不是交流系统原理和结构的理想媒介。团队更需要编制容易看懂的文档，来对系统及其设计决策的依据进行描述。

   然而，过多的文档比过少的文档更糟。编制众多的文档需要花费大量的时间，并且使这些文档和代码保持同步，要花费更多的时间。如果文档和代码之间失去同步，那么文档就会变成庞大的、复杂的谎言，会造成重大的误导。

   对于团队来说，编写并维护一份系统原理和结构方面的文档总是一个好主意，但是那份文档应该短小并且主题突出。短小的意思是说，最多有一二十页。主题突出的意思是说，应该仅论述系统的最高层结构和概括的设计原理。

   如果我们拥有的仅仅是一份简短的系统原理和结构方面的文档，那么如何来培训新的团队成员，使他们能够从事系统相关的工作呢？我们会非常密切地和他们一起工作。我们紧挨着他们坐下来帮助他们，把我们的知识传授给他们。我们通过频繁的培训和交互使他们成为团队的一部分。

   在向新的团队成员传授知识方面，最好的两份文档是代码和团队。代码真实地表达了它所做的事情。虽然从代码中提取系统的原理和结构信息可能是困难的，但是代码是唯一没有二义性的信息源。在团队成员的头脑中，保存着时常变化的系统的脉络图。人和人之间的交互是比把这份脉络图记在纸上并传授给他人更快、更有效的方式。

3. 成功的项目需要定期且频繁的客户反馈。不是依赖于合同或者关于工作的陈述，而是让软件的客户和开发团队密切地工作在一起，并尽量经常地提供反馈。

4. 计划不能考虑得过远。首先，商务环境很可能会变化，这会引起需求的变动。其次，一旦客户看到系统开始运作，他们很可能会改变需求。最后，即使我们知道需求是什么，并且确信它们不会改变，我们仍然不能很好地估算出开发它们需要的时间。

#### 敏捷宣言遵循原则

我们最优先要做的是通过尽早地、持续地交付有价值的软件来满足客户需要。我们欢迎需求的变化，即使到了开发后期。敏捷过程能够驾驭变化，为客户创造竞争优势。经常交付可以工作的软件，从几个星期到几个月，时间间隔越短越好。

在整个项目开发期间，业务人员和开发人员必须朝夕工作在一起。依靠斗志高昂的人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成任务。在团队内部，最有效率也最有效果的信息传达方式，就是面对面的交谈。可以工作的软件是进度主要的度量标准。

敏捷过程提倡可持续开发。出资人、开发者和用户应该总是保持稳定的开发速度。对卓越技术和良好设计的不断追求有助于提高敏捷性。简单——尽量减少工作量的艺术是至关重要的。

最好的构架、需求和设计都源自自我组织的团队。每隔一定时间，团队都要总结如何更有效率，然后相应地调整自己的行为。

#### 敏捷软件开发过程

有许多的敏捷过程可供选择，包括SCRUM  、Crystal 、特征驱动软件开发（Feature-Driven Development，FDD）、自适应软件开发（Adaptive Software Development， ADP）以及极限编程（Extreme Programming，XP）。

常见的做法是把SCRUM和XP结合起来，其中使用SCRUM实践来管理多个使用XP实践的团队。

### 实践

#### 极限编程 XP

极限编程是一组简单、具体的实践，这些实践结合在一起形成了一个敏捷开发过程。极限编程是一种优良、通用的软件开发方法。对于大多数项目团队来说，可以拿来直接采用，也可以增加一些实践，或者对其中的一些实践进行修改后再采用。

1. 测试驱动开发

   当为了使测试用例通过而编写代码时，那么所编写的代码天生就是可测试的。更重要的是，这样做会强烈地激发你去解除各个模块间的耦合，以便能够独立地对它们进行测试。因而，以这种方式编写的代码的设计往往具有更弱的耦合。面向对象设计的原则在进行这种解耦方面具有巨大的帮助作用。

2. 重构

   代码往往会腐化。随着我们添加一个又一个的特性，处理一个又一个的错误，代码的结构会逐渐退化。如果对此置之不理的话，这种退化最终会导致纠结不清、难于维护的混乱代码。

   XP团队通过经常性的代码重构来扭转这种退化。重构就是在不改变代码行为的前提下，对其进行一系列小的改造，旨在改进系统结构的实践活动。每个改造都是微不足道的，几乎不值得去做。但是所有的这些改造叠加在一起，就形成了对系统设计和构架显著的改进。

3. 隐喻

   隐喻（metaphor）是唯一一个不具体、不直接的XP实践，也是所有XP实践中最难理解的一个。极限编程者在本质上都是务实主义者，隐喻这个缺乏具体定义的概念使我们觉得很不舒服。

   想象一下智力拼图玩具。你怎样知道如何把各个小块拼在一起？显然，每一块都与其他块相邻，并且它的形状必须与相邻的块完美地吻合。如果你眼睛看不见但是具有很好的触觉，那么通过锲而不舍地筛选每个小块，不断地尝试它们的位置，也能够拼出整个图形。
   但是，相对于各个小块的形状而言，还有一种更为强大的力量把这些复杂的小块拼装在一起。这就是整张拼图的图案。图案是真正的向导。它的力量是如此之大，以至于如果图案中相邻的两块不具有互相吻合的形状，那么你就可以断定拼图玩具的制作者把玩具做错了。

   这就是隐喻。它是将整个系统联系在一起的全局视图。它是系统的愿景，是它使得所有单独模块的位置和外观变得明显直观。如果模块的外观与整个系统的隐喻不符，那么你就知道该模块是错误的。

   隐喻通常可以归结为一个名字系统。这些名字提供了一个系统组成元素的词汇表，并且有助于定义它们之间的关系。当然，隐喻不仅仅是一个名字系统。隐喻是系统的愿景，它指导着所有开发者去选择合适的名字，把函数放到合适的位置，创建出新的合适的类和方法，等等。

4. 计划

   计划游戏（planning game）的本质是划分业务和开发之间的职责。业务人员（也就是客户）决定特性的重要性，开发人员决定实现一个特性所花费的代价。

   在每次发布和迭代的开始，开发人员向客户提供一个预算。客户选择那些所需的代价合计起来小于等于该预算的用户故事。开发者所提供的预算是基于他们在最近一次迭代或者发布中所完成的工作量进行的。

5. ... ... 

