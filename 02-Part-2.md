### 单一责任原则（ The Single Responsibility Principle，SRP）

内聚性：一个模块的组成元素之间的功能相关性。

单一职责原则：一个类应该只有一个发生变化的原因。

为何把职责分离到单独的类中很重要呢？因为每一个职责都是变化的一个轴线。当需求变化时，该变化会反映为类的职责的变化。如果一个类承担了多于一个的职责，那么引起它变化的原因就会有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

### 开放封闭原则（The Open-Close Principle，OCP）

软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。

在许多方面，OCP都是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处：灵活性、可重用性以及可维护性。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确的做法是，开发人员应该仅仅对程序中呈现出频繁变化的那些部分做出抽象。拒绝不成熟的抽象和抽象本身一样重要。

### Liskov替换原则（The Liskov Substitution Principle，LSP）

OCP背后的主要机制是抽象和多态。使用了继承，我们才可以创建实现其基类中抽象方法的派生类。是什么设计规则在支配着这种特殊的继承用法呢？最佳的继承层次的特征又是什么呢？怎样的情况会使我们创建的类层次结构掉进不符合OCP的陷阱中去呢？这些正是Liskov替换原则（LSP）要解答的问题。

子类型（subtype）必须能够替换掉它们的基类型（base type）。若对类型S的每一个对象o1 ，都存在一个类型T的对象o2 ，使得在所有针对T编写的程序P中，用o1 替换o2后，程序P的行为功能不变，则S是T的子类型。

有一项技术可以使这些合理的假设明确化，从而支持了LSP。这项技术被称为基于契约设计（Design By Contract，DBC）。契约是通过为每个方法声明前置条件（precondition）和后置条件（postcondition）来指定
的。要使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。派生类的前置条件和后置条件规则是：“在重新声明派生类中的例程时，只能使用相等或者更弱的前置条件来替换原始的 前置条件，只能使用相等或者更强的后置条件来替换原始的后置条件。”


### 依赖倒置原则（The Dependency-Inversion Principle，DIP）

a.高层模块不应该依赖于低层模块。二者都应该依赖于抽象；b.抽象不应该依赖于细节。细节应该依赖于抽象。

### 接口隔离原则（The Interface Segregation Principle，ISP）

这个原则用来处理“胖”接口所存在的缺点。如果类的接口不是内聚的，就表示该类具有“胖”接口。ISP承认有一些对象确实需要有非内聚的接口，但是ISP建议客户程序不应该看到它们作为单一的类存在。相反，客户程序看到的应该是多个具有内聚接口的抽象基类。
